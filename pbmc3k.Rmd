---
title: "pbmc3k"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{pbmc3k}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

Here we explore the use of `sneezy` on the 10x genomics PBMC3k single-cell
dataset. We follow the preprocessing and quality control steps from
[Chapter 25 of Orchestrating Single Cell Analysis with R](https://osca.bioconductor.org/pbmc-3k-10x-dataset-filtered.html), and
use that to explore the linear and non-linear embedding spaces via tours
and diagnostics.

## Setup

First, we load up the raw data from the `TENxPBMCData` package,
and the analysis packages `scater` and `scran`:

```{r setup}
library(TENxPBMCData)
library(scater)
library(scran)

pbmc3k <- TENxPBMCData("pbmc3k")
pbmc3k
```

Next we follow the simple QC steps from the aforementioned vignette:

### Quality control

```{r qc}
is.mito <- grep("MT", rowData(pbmc3k)$Symbol_TENx)
stats <- perCellQCMetrics(pbmc3k, subsets=list(Mito=is.mito))
high.mito <- isOutlier(stats$subsets_Mito_percent, nmads=3, type="higher")
pbmc3k <- pbmc3k[,!high.mito]
```

### Normalization

```{r}
pbmc3k <- logNormCounts(pbmc3k)
```

### Variance modelling

```{r}
dec3k <- modelGeneVar(pbmc3k)
chosen.hvgs <- which(dec3k$bio > 0)
```


## Estimating embeddings

`liminal` is agnostic about how you construct your embedding and leaves
that problem for other R packages. In this example,
we use the `scater` package to directly estimate principal componenets
and t-SNE embeddings.

```{r}
set.seed(2099)
pbmc3k <- runPCA(pbmc3k, 
                 ncomponents = 15,
                 subset_row = chosen.hvgs,
                 BSPARAM = BiocSingular::RandomParam(),
                 name = "pca")

set.seed(1999)
pbmc3k <- runTSNE(pbmc3k,
                  subset_row = chosen.hvgs,
                  perplexity = 30,
                  name = "tsne")
```

The arguments above add an embedding to the pbmc3k object,
using randomized PCA, only on the highly variable genes we've constructed 
above. Since, the procedure is random, we also set a seed. 

The usual approach here is to inspect the results of a cluster
analysis on top of an embedding, here we have used the standard arguments
as used by `scran`:

```{r}
g <- buildSNNGraph(pbmc3k, k=15, use.dimred = 'pca')
clust <- igraph::cluster_louvain(g)
pbmc3k$cluster <- factor(igraph::membership(clust))

```


## Visualsing results

All liminal visualisations take a data.frame/tibble as input.
For example, we can flatten the single cell experiment object into a
data.frame with the following code:

```{r flatten}
tsne_tbl <- data.frame(
  tsne_x = reducedDim(pbmc3k, "tsne")[,1],
  tsne_y = reducedDim(pbmc3k, "tsne")[,2],
  cluster = pbmc3k$cluster
)

express <- t(logcounts(pbmc3k)[chosen.hvgs,])
colnames(express) <- rowData(pbmc3k)[chosen.hvgs, "Symbol_TENx"]
express <- as.data.frame(express)
tsne_tbl <- dplyr::bind_cols(
  tsne_tbl,
  express
)
```

And we can generate a simple xy view 
```{r}
library(liminal)
limn_xy(tsne_tbl, x= tsne_x, y = tsne_y, color = cluster)
```

Or alternatively, we can view a set of marker genes:

```{r}
limn_xycol(tsne_tbl, 
           x = tsne_x, y = tsne_y, 
           colors = c(CD79A, MS4A1, CD8A, CD8B, LYZ))
```

We can generate a tour (this will load a shiny application)

```{r, eval = FALSE}
limn_tbl <- dplyr::bind_cols(
  as.data.frame(reducedDim(pbmc3k, "pca")),
  cluster = pbmc3k$cluster
)
limn_tour(limn_tbl, PC1:PC10, color = cluster)
```

We can generate a linked tour 

```{r, eval = FALSE}
limn_tour_xylink(dplyr::select(limn_tbl, PC1:PC10, cluster),
                 tsne_tbl,
                 x_color = cluster,
                 y_color = cluster
)
```
